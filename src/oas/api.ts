/* tslint:disable */
/* eslint-disable */
/**
 * Threads API
 * The threads API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
    /**
     * The actor ID
     * @type {string}
     * @memberof AccountDto
     */
    'id': string;
    /**
     * The account slug
     * @type {string}
     * @memberof AccountDto
     */
    'accountSlug': string;
    /**
     * The account name
     * @type {string}
     * @memberof AccountDto
     */
    'accountName': string;
    /**
     * The token
     * @type {string}
     * @memberof AccountDto
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ActorDTO
 */
export interface ActorDTO {
    /**
     * The actor ID
     * @type {string}
     * @memberof ActorDTO
     */
    'id': string;
    /**
     * The actor external ID
     * @type {string}
     * @memberof ActorDTO
     */
    'externalId': string;
    /**
     * The actor providers
     * @type {Array<ActorProviderDTO>}
     * @memberof ActorDTO
     */
    'providers': Array<ActorProviderDTO>;
    /**
     * The tags.
     * @type {Array<TagValueDTO>}
     * @memberof ActorDTO
     */
    'tags'?: Array<TagValueDTO>;
}
/**
 * 
 * @export
 * @interface ActorProviderDTO
 */
export interface ActorProviderDTO {
    /**
     * The actor ID
     * @type {string}
     * @memberof ActorProviderDTO
     */
    'id': string;
    /**
     * The actor external ID
     * @type {string}
     * @memberof ActorProviderDTO
     */
    'externalId': string;
    /**
     * The actor available providers
     * @type {string}
     * @memberof ActorProviderDTO
     */
    'providerSlug': string;
    /**
     * The actor identifier (given by provider)
     * @type {string}
     * @memberof ActorProviderDTO
     */
    'identifier': string;
    /**
     * The actor provider specific data
     * @type {object}
     * @memberof ActorProviderDTO
     */
    'providerSpecificData': object;
    /**
     * The tags.
     * @type {Array<TagValueDTO>}
     * @memberof ActorProviderDTO
     */
    'tags': Array<TagValueDTO>;
}
/**
 * 
 * @export
 * @interface CreateAccountDto
 */
export interface CreateAccountDto {
    /**
     * The account slug
     * @type {string}
     * @memberof CreateAccountDto
     */
    'accountSlug': string;
    /**
     * The account name
     * @type {string}
     * @memberof CreateAccountDto
     */
    'accountName': string;
}
/**
 * 
 * @export
 * @interface CreateActorDTO
 */
export interface CreateActorDTO {
    /**
     * The actor external ID
     * @type {string}
     * @memberof CreateActorDTO
     */
    'externalId': string;
    /**
     * The actor providers
     * @type {Array<CreateActorProviderDTO>}
     * @memberof CreateActorDTO
     */
    'providers': Array<CreateActorProviderDTO>;
    /**
     * The tags.
     * @type {Array<TagValueDTO>}
     * @memberof CreateActorDTO
     */
    'tags'?: Array<TagValueDTO>;
}
/**
 * 
 * @export
 * @interface CreateActorProviderDTO
 */
export interface CreateActorProviderDTO {
    /**
     * The actor external ID
     * @type {string}
     * @memberof CreateActorProviderDTO
     */
    'externalId': string;
    /**
     * The actor available providers
     * @type {string}
     * @memberof CreateActorProviderDTO
     */
    'providerSlug': string;
    /**
     * The actor identifier (given by provider)
     * @type {string}
     * @memberof CreateActorProviderDTO
     */
    'identifier': string;
    /**
     * The actor provider specific data
     * @type {object}
     * @memberof CreateActorProviderDTO
     */
    'providerSpecificData': object;
    /**
     * The tags.
     * @type {Array<TagValueDTO>}
     * @memberof CreateActorProviderDTO
     */
    'tags'?: Array<TagValueDTO>;
}
/**
 * 
 * @export
 * @interface CreateMessageDTO
 */
export interface CreateMessageDTO {
    /**
     * The message text
     * @type {string}
     * @memberof CreateMessageDTO
     */
    'text': string;
    /**
     * The actor ID
     * @type {string}
     * @memberof CreateMessageDTO
     */
    'actorId': string;
    /**
     * The actor\'s provider ID
     * @type {string}
     * @memberof CreateMessageDTO
     */
    'providerId': string;
    /**
     * The name of the template to use
     * @type {string}
     * @memberof CreateMessageDTO
     */
    'templateName': string;
    /**
     * The parameters to use in the template
     * @type {object}
     * @memberof CreateMessageDTO
     */
    'templateParams': object;
    /**
     * The tags.
     * @type {Array<TagValueDTO>}
     * @memberof CreateMessageDTO
     */
    'tags'?: Array<TagValueDTO>;
}
/**
 * 
 * @export
 * @interface CreateMessageTemplateDto
 */
export interface CreateMessageTemplateDto {
    /**
     * The name of the message template
     * @type {string}
     * @memberof CreateMessageTemplateDto
     */
    'name': string;
    /**
     * The subject of the message template
     * @type {string}
     * @memberof CreateMessageTemplateDto
     */
    'subject': string;
    /**
     * The HTML content of the message template
     * @type {string}
     * @memberof CreateMessageTemplateDto
     */
    'htmlContent': string;
    /**
     * The text content of the message template
     * @type {string}
     * @memberof CreateMessageTemplateDto
     */
    'textContent': string;
    /**
     * JSON schema for template parameters
     * @type {object}
     * @memberof CreateMessageTemplateDto
     */
    'jsonSchema'?: object;
}
/**
 * 
 * @export
 * @interface CreateTagDTO
 */
export interface CreateTagDTO {
    /**
     * The tag key
     * @type {string}
     * @memberof CreateTagDTO
     */
    'key': string;
    /**
     * The tag value
     * @type {string}
     * @memberof CreateTagDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface CreateThreadDTO
 */
export interface CreateThreadDTO {
    /**
     * The actors
     * @type {Array<CreateActorDTO>}
     * @memberof CreateThreadDTO
     */
    'actors': Array<CreateActorDTO>;
    /**
     * The messages
     * @type {Array<CreateMessageDTO>}
     * @memberof CreateThreadDTO
     */
    'messages': Array<CreateMessageDTO>;
    /**
     * The subject
     * @type {string}
     * @memberof CreateThreadDTO
     */
    'subject': string;
    /**
     * The topic external ID
     * @type {string}
     * @memberof CreateThreadDTO
     */
    'externalId': string;
    /**
     * The tags.
     * @type {Array<TagValueDTO>}
     * @memberof CreateThreadDTO
     */
    'tags'?: Array<TagValueDTO>;
}
/**
 * 
 * @export
 * @interface CreateTopicDTO
 */
export interface CreateTopicDTO {
    /**
     * The topic external ID
     * @type {string}
     * @memberof CreateTopicDTO
     */
    'externalId': string;
    /**
     * The tags
     * @type {Array<CreateTagDTO>}
     * @memberof CreateTopicDTO
     */
    'tags': Array<CreateTagDTO>;
}
/**
 * 
 * @export
 * @interface MessageDTO
 */
export interface MessageDTO {
    /**
     * The message ID
     * @type {string}
     * @memberof MessageDTO
     */
    'id': string;
    /**
     * The message text
     * @type {string}
     * @memberof MessageDTO
     */
    'text': string;
    /**
     * Experimental. Try and remove the quoted text from the message text and return just the new content.
     * @type {string}
     * @memberof MessageDTO
     */
    'parsedText': string;
    /**
     * The actor ID
     * @type {string}
     * @memberof MessageDTO
     */
    'actorId': string;
    /**
     * The actor\'s provider ID used in the message
     * @type {string}
     * @memberof MessageDTO
     */
    'providerId': string;
}
/**
 * 
 * @export
 * @interface MessageTemplateDto
 */
export interface MessageTemplateDto {
    /**
     * The message template name
     * @type {string}
     * @memberof MessageTemplateDto
     */
    'name': string;
    /**
     * The message template subject
     * @type {string}
     * @memberof MessageTemplateDto
     */
    'subject': string;
    /**
     * The message template HTML content
     * @type {string}
     * @memberof MessageTemplateDto
     */
    'htmlContent': string;
    /**
     * The message template text content
     * @type {string}
     * @memberof MessageTemplateDto
     */
    'textContent': string;
    /**
     * JSON schema for template parameters
     * @type {object}
     * @memberof MessageTemplateDto
     */
    'jsonSchema'?: object;
}
/**
 * 
 * @export
 * @interface ProviderConfigurationDTO
 */
export interface ProviderConfigurationDTO {
    /**
     * The provider name
     * @type {string}
     * @memberof ProviderConfigurationDTO
     */
    'providerName': string;
    /**
     * The provider configuration
     * @type {object}
     * @memberof ProviderConfigurationDTO
     */
    'providerConfig': object;
}
/**
 * 
 * @export
 * @interface QueueDto
 */
export interface QueueDto {
    /**
     * The unique identifier of the message
     * @type {string}
     * @memberof QueueDto
     */
    'messageId': string;
    /**
     * The identifier of the message this is a reply to
     * @type {string}
     * @memberof QueueDto
     */
    'inReplyTo'?: string;
    /**
     * An array of message identifiers that this message references
     * @type {Array<string>}
     * @memberof QueueDto
     */
    'references'?: Array<string>;
    /**
     * The recipient of the message
     * @type {string}
     * @memberof QueueDto
     */
    'to': string;
    /**
     * The sender of the message
     * @type {string}
     * @memberof QueueDto
     */
    'from': string;
    /**
     * The subject of the message
     * @type {string}
     * @memberof QueueDto
     */
    'subject': string;
    /**
     * The plain text content of the message
     * @type {string}
     * @memberof QueueDto
     */
    'textContent': string;
    /**
     * The HTML content of the message
     * @type {string}
     * @memberof QueueDto
     */
    'htmlContent'?: string;
    /**
     * The provider of the communication channel
     * @type {string}
     * @memberof QueueDto
     */
    'provider': string;
    /**
     * Additional information related to the message
     * @type {object}
     * @memberof QueueDto
     */
    'extraInfo': object;
    /**
     * The status of the message
     * @type {string}
     * @memberof QueueDto
     */
    'status': QueueDtoStatusEnum;
    /**
     * The date and time the message was created
     * @type {string}
     * @memberof QueueDto
     */
    'createdAt': string;
    /**
     * The date and time the message was last updated
     * @type {string}
     * @memberof QueueDto
     */
    'updatedAt': string;
}

export const QueueDtoStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed',
    Skipped: 'skipped',
    Ignored: 'ignored',
    Deleted: 'deleted',
    Archived: 'archived',
    Spam: 'spam',
    Ham: 'ham',
    Bounce: 'bounce',
    Complaint: 'complaint',
    Unsubscribed: 'unsubscribed',
    Other: 'other'
} as const;

export type QueueDtoStatusEnum = typeof QueueDtoStatusEnum[keyof typeof QueueDtoStatusEnum];

/**
 * 
 * @export
 * @interface TagDTO
 */
export interface TagDTO {
    /**
     * The tag ID
     * @type {string}
     * @memberof TagDTO
     */
    'id': string;
    /**
     * The tag key
     * @type {string}
     * @memberof TagDTO
     */
    'key': string;
    /**
     * The tag value
     * @type {string}
     * @memberof TagDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TagValueDTO
 */
export interface TagValueDTO {
    /**
     * The tag key
     * @type {string}
     * @memberof TagValueDTO
     */
    'key': string;
    /**
     * The tag value
     * @type {string}
     * @memberof TagValueDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ThreadDTO
 */
export interface ThreadDTO {
    /**
     * The message ID
     * @type {string}
     * @memberof ThreadDTO
     */
    'id': string;
    /**
     * The actors
     * @type {Array<ActorDTO>}
     * @memberof ThreadDTO
     */
    'actors': Array<ActorDTO>;
    /**
     * The messages
     * @type {Array<MessageDTO>}
     * @memberof ThreadDTO
     */
    'messages': Array<MessageDTO>;
    /**
     * The subject
     * @type {string}
     * @memberof ThreadDTO
     */
    'subject': string;
    /**
     * The thread external ID
     * @type {string}
     * @memberof ThreadDTO
     */
    'externalId': string;
    /**
     * The tags.
     * @type {Array<TagValueDTO>}
     * @memberof ThreadDTO
     */
    'tags'?: Array<TagValueDTO>;
}
/**
 * 
 * @export
 * @interface TopicDTO
 */
export interface TopicDTO {
    /**
     * The topic ID
     * @type {string}
     * @memberof TopicDTO
     */
    'id': string;
    /**
     * The topic external ID
     * @type {string}
     * @memberof TopicDTO
     */
    'externalId': string;
    /**
     * The tags
     * @type {TagDTO}
     * @memberof TopicDTO
     */
    'tags': TagDTO;
    /**
     * The threads
     * @type {ThreadDTO}
     * @memberof TopicDTO
     */
    'threads': ThreadDTO;
}
/**
 * 
 * @export
 * @interface TopicFilterDTO
 */
export interface TopicFilterDTO {
    /**
     * The topic IDs. The ids will be queried using OR.
     * @type {Array<string>}
     * @memberof TopicFilterDTO
     */
    'id'?: Array<string>;
    /**
     * The topic external IDs. The ids will be queried using OR.
     * @type {Array<string>}
     * @memberof TopicFilterDTO
     */
    'externalId'?: Array<string>;
    /**
     * The tags. The tags will be queried using the OR.
     * @type {Array<TagValueDTO>}
     * @memberof TopicFilterDTO
     */
    'tags'?: Array<TagValueDTO>;
}
/**
 * 
 * @export
 * @interface UpdateMessageTemplateDto
 */
export interface UpdateMessageTemplateDto {
    /**
     * The subject of the message template
     * @type {string}
     * @memberof UpdateMessageTemplateDto
     */
    'subject': string;
    /**
     * The HTML content of the message template
     * @type {string}
     * @memberof UpdateMessageTemplateDto
     */
    'htmlContent': string;
    /**
     * The text content of the message template
     * @type {string}
     * @memberof UpdateMessageTemplateDto
     */
    'textContent': string;
    /**
     * JSON schema for template parameters
     * @type {object}
     * @memberof UpdateMessageTemplateDto
     */
    'jsonSchema'?: object;
}

/**
 * ExternalProvidersSNSApi - axios parameter creator
 * @export
 */
export const ExternalProvidersSNSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snsControllerReceiveSns: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers/sns/receive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalProvidersSNSApi - functional programming interface
 * @export
 */
export const ExternalProvidersSNSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalProvidersSNSApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snsControllerReceiveSns(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snsControllerReceiveSns(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalProvidersSNSApi.snsControllerReceiveSns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExternalProvidersSNSApi - factory interface
 * @export
 */
export const ExternalProvidersSNSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalProvidersSNSApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snsControllerReceiveSns(options?: any): AxiosPromise<void> {
            return localVarFp.snsControllerReceiveSns(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalProvidersSNSApi - object-oriented interface
 * @export
 * @class ExternalProvidersSNSApi
 * @extends {BaseAPI}
 */
export class ExternalProvidersSNSApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalProvidersSNSApi
     */
    public snsControllerReceiveSns(options?: RawAxiosRequestConfig) {
        return ExternalProvidersSNSApiFp(this.configuration).snsControllerReceiveSns(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalAccountsApi - axios parameter creator
 * @export
 */
export const InternalAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new account
         * @param {CreateAccountDto} createAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreate: async (createAccountDto: CreateAccountDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountDto' is not null or undefined
            assertParamExists('accountsControllerCreate', 'createAccountDto', createAccountDto)
            const localVarPath = `/internal/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account by id
         * @param {string} accountSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerFindOne: async (accountSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountSlug' is not null or undefined
            assertParamExists('accountsControllerFindOne', 'accountSlug', accountSlug)
            const localVarPath = `/internal/accounts/{accountSlug}`
                .replace(`{${"accountSlug"}}`, encodeURIComponent(String(accountSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete account by id
         * @param {string} accountSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerRemove: async (accountSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountSlug' is not null or undefined
            assertParamExists('accountsControllerRemove', 'accountSlug', accountSlug)
            const localVarPath = `/internal/accounts/{accountSlug}`
                .replace(`{${"accountSlug"}}`, encodeURIComponent(String(accountSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalAccountsApi - functional programming interface
 * @export
 */
export const InternalAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new account
         * @param {CreateAccountDto} createAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerCreate(createAccountDto: CreateAccountDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerCreate(createAccountDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalAccountsApi.accountsControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalAccountsApi.accountsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account by id
         * @param {string} accountSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerFindOne(accountSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerFindOne(accountSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalAccountsApi.accountsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete account by id
         * @param {string} accountSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerRemove(accountSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerRemove(accountSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalAccountsApi.accountsControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternalAccountsApi - factory interface
 * @export
 */
export const InternalAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalAccountsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new account
         * @param {CreateAccountDto} createAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreate(createAccountDto: CreateAccountDto, options?: any): AxiosPromise<AccountDto> {
            return localVarFp.accountsControllerCreate(createAccountDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerFindAll(options?: any): AxiosPromise<Array<AccountDto>> {
            return localVarFp.accountsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account by id
         * @param {string} accountSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerFindOne(accountSlug: string, options?: any): AxiosPromise<AccountDto> {
            return localVarFp.accountsControllerFindOne(accountSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete account by id
         * @param {string} accountSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerRemove(accountSlug: string, options?: any): AxiosPromise<AccountDto> {
            return localVarFp.accountsControllerRemove(accountSlug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalAccountsApi - object-oriented interface
 * @export
 * @class InternalAccountsApi
 * @extends {BaseAPI}
 */
export class InternalAccountsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new account
     * @param {CreateAccountDto} createAccountDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalAccountsApi
     */
    public accountsControllerCreate(createAccountDto: CreateAccountDto, options?: RawAxiosRequestConfig) {
        return InternalAccountsApiFp(this.configuration).accountsControllerCreate(createAccountDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalAccountsApi
     */
    public accountsControllerFindAll(options?: RawAxiosRequestConfig) {
        return InternalAccountsApiFp(this.configuration).accountsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account by id
     * @param {string} accountSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalAccountsApi
     */
    public accountsControllerFindOne(accountSlug: string, options?: RawAxiosRequestConfig) {
        return InternalAccountsApiFp(this.configuration).accountsControllerFindOne(accountSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete account by id
     * @param {string} accountSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalAccountsApi
     */
    public accountsControllerRemove(accountSlug: string, options?: RawAxiosRequestConfig) {
        return InternalAccountsApiFp(this.configuration).accountsControllerRemove(accountSlug, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalAccountsProviderConfigurationApi - axios parameter creator
 * @export
 */
export const InternalAccountsProviderConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new provider configuration
         * @param {string} accountSlug 
         * @param {ProviderConfigurationDTO} providerConfigurationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerConfigurationControllerAddProviderConfiguration: async (accountSlug: string, providerConfigurationDTO: ProviderConfigurationDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountSlug' is not null or undefined
            assertParamExists('providerConfigurationControllerAddProviderConfiguration', 'accountSlug', accountSlug)
            // verify required parameter 'providerConfigurationDTO' is not null or undefined
            assertParamExists('providerConfigurationControllerAddProviderConfiguration', 'providerConfigurationDTO', providerConfigurationDTO)
            const localVarPath = `/internal/accounts/{accountSlug}/provider-configurations`
                .replace(`{${"accountSlug"}}`, encodeURIComponent(String(accountSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(providerConfigurationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a provider configuration
         * @param {string} accountSlug 
         * @param {string} providerName Name of the provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerConfigurationControllerDeleteProviderConfiguration: async (accountSlug: string, providerName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountSlug' is not null or undefined
            assertParamExists('providerConfigurationControllerDeleteProviderConfiguration', 'accountSlug', accountSlug)
            // verify required parameter 'providerName' is not null or undefined
            assertParamExists('providerConfigurationControllerDeleteProviderConfiguration', 'providerName', providerName)
            const localVarPath = `/internal/accounts/{accountSlug}/provider-configurations/{providerName}`
                .replace(`{${"accountSlug"}}`, encodeURIComponent(String(accountSlug)))
                .replace(`{${"providerName"}}`, encodeURIComponent(String(providerName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all provider configurations
         * @param {string} accountSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerConfigurationControllerGetProviderConfigurations: async (accountSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountSlug' is not null or undefined
            assertParamExists('providerConfigurationControllerGetProviderConfigurations', 'accountSlug', accountSlug)
            const localVarPath = `/internal/accounts/{accountSlug}/provider-configurations`
                .replace(`{${"accountSlug"}}`, encodeURIComponent(String(accountSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a provider configuration
         * @param {string} accountSlug 
         * @param {string} providerName Name of the provider
         * @param {ProviderConfigurationDTO} providerConfigurationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerConfigurationControllerUpdateProviderConfiguration: async (accountSlug: string, providerName: string, providerConfigurationDTO: ProviderConfigurationDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountSlug' is not null or undefined
            assertParamExists('providerConfigurationControllerUpdateProviderConfiguration', 'accountSlug', accountSlug)
            // verify required parameter 'providerName' is not null or undefined
            assertParamExists('providerConfigurationControllerUpdateProviderConfiguration', 'providerName', providerName)
            // verify required parameter 'providerConfigurationDTO' is not null or undefined
            assertParamExists('providerConfigurationControllerUpdateProviderConfiguration', 'providerConfigurationDTO', providerConfigurationDTO)
            const localVarPath = `/internal/accounts/{accountSlug}/provider-configurations/{providerName}`
                .replace(`{${"accountSlug"}}`, encodeURIComponent(String(accountSlug)))
                .replace(`{${"providerName"}}`, encodeURIComponent(String(providerName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(providerConfigurationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalAccountsProviderConfigurationApi - functional programming interface
 * @export
 */
export const InternalAccountsProviderConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalAccountsProviderConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new provider configuration
         * @param {string} accountSlug 
         * @param {ProviderConfigurationDTO} providerConfigurationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerConfigurationControllerAddProviderConfiguration(accountSlug: string, providerConfigurationDTO: ProviderConfigurationDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderConfigurationDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerConfigurationControllerAddProviderConfiguration(accountSlug, providerConfigurationDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalAccountsProviderConfigurationApi.providerConfigurationControllerAddProviderConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a provider configuration
         * @param {string} accountSlug 
         * @param {string} providerName Name of the provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerConfigurationControllerDeleteProviderConfiguration(accountSlug: string, providerName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderConfigurationDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerConfigurationControllerDeleteProviderConfiguration(accountSlug, providerName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalAccountsProviderConfigurationApi.providerConfigurationControllerDeleteProviderConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all provider configurations
         * @param {string} accountSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerConfigurationControllerGetProviderConfigurations(accountSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderConfigurationDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerConfigurationControllerGetProviderConfigurations(accountSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalAccountsProviderConfigurationApi.providerConfigurationControllerGetProviderConfigurations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a provider configuration
         * @param {string} accountSlug 
         * @param {string} providerName Name of the provider
         * @param {ProviderConfigurationDTO} providerConfigurationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerConfigurationControllerUpdateProviderConfiguration(accountSlug: string, providerName: string, providerConfigurationDTO: ProviderConfigurationDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderConfigurationDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerConfigurationControllerUpdateProviderConfiguration(accountSlug, providerName, providerConfigurationDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalAccountsProviderConfigurationApi.providerConfigurationControllerUpdateProviderConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternalAccountsProviderConfigurationApi - factory interface
 * @export
 */
export const InternalAccountsProviderConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalAccountsProviderConfigurationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new provider configuration
         * @param {string} accountSlug 
         * @param {ProviderConfigurationDTO} providerConfigurationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerConfigurationControllerAddProviderConfiguration(accountSlug: string, providerConfigurationDTO: ProviderConfigurationDTO, options?: any): AxiosPromise<Array<ProviderConfigurationDTO>> {
            return localVarFp.providerConfigurationControllerAddProviderConfiguration(accountSlug, providerConfigurationDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a provider configuration
         * @param {string} accountSlug 
         * @param {string} providerName Name of the provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerConfigurationControllerDeleteProviderConfiguration(accountSlug: string, providerName: string, options?: any): AxiosPromise<Array<ProviderConfigurationDTO>> {
            return localVarFp.providerConfigurationControllerDeleteProviderConfiguration(accountSlug, providerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all provider configurations
         * @param {string} accountSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerConfigurationControllerGetProviderConfigurations(accountSlug: string, options?: any): AxiosPromise<Array<ProviderConfigurationDTO>> {
            return localVarFp.providerConfigurationControllerGetProviderConfigurations(accountSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a provider configuration
         * @param {string} accountSlug 
         * @param {string} providerName Name of the provider
         * @param {ProviderConfigurationDTO} providerConfigurationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerConfigurationControllerUpdateProviderConfiguration(accountSlug: string, providerName: string, providerConfigurationDTO: ProviderConfigurationDTO, options?: any): AxiosPromise<Array<ProviderConfigurationDTO>> {
            return localVarFp.providerConfigurationControllerUpdateProviderConfiguration(accountSlug, providerName, providerConfigurationDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalAccountsProviderConfigurationApi - object-oriented interface
 * @export
 * @class InternalAccountsProviderConfigurationApi
 * @extends {BaseAPI}
 */
export class InternalAccountsProviderConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary Add a new provider configuration
     * @param {string} accountSlug 
     * @param {ProviderConfigurationDTO} providerConfigurationDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalAccountsProviderConfigurationApi
     */
    public providerConfigurationControllerAddProviderConfiguration(accountSlug: string, providerConfigurationDTO: ProviderConfigurationDTO, options?: RawAxiosRequestConfig) {
        return InternalAccountsProviderConfigurationApiFp(this.configuration).providerConfigurationControllerAddProviderConfiguration(accountSlug, providerConfigurationDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a provider configuration
     * @param {string} accountSlug 
     * @param {string} providerName Name of the provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalAccountsProviderConfigurationApi
     */
    public providerConfigurationControllerDeleteProviderConfiguration(accountSlug: string, providerName: string, options?: RawAxiosRequestConfig) {
        return InternalAccountsProviderConfigurationApiFp(this.configuration).providerConfigurationControllerDeleteProviderConfiguration(accountSlug, providerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all provider configurations
     * @param {string} accountSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalAccountsProviderConfigurationApi
     */
    public providerConfigurationControllerGetProviderConfigurations(accountSlug: string, options?: RawAxiosRequestConfig) {
        return InternalAccountsProviderConfigurationApiFp(this.configuration).providerConfigurationControllerGetProviderConfigurations(accountSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a provider configuration
     * @param {string} accountSlug 
     * @param {string} providerName Name of the provider
     * @param {ProviderConfigurationDTO} providerConfigurationDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalAccountsProviderConfigurationApi
     */
    public providerConfigurationControllerUpdateProviderConfiguration(accountSlug: string, providerName: string, providerConfigurationDTO: ProviderConfigurationDTO, options?: RawAxiosRequestConfig) {
        return InternalAccountsProviderConfigurationApiFp(this.configuration).providerConfigurationControllerUpdateProviderConfiguration(accountSlug, providerName, providerConfigurationDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicMessageTemplatesApi - axios parameter creator
 * @export
 */
export const PublicMessageTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new message template
         * @param {CreateMessageTemplateDto} createMessageTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerCreate: async (createMessageTemplateDto: CreateMessageTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMessageTemplateDto' is not null or undefined
            assertParamExists('messageTemplatesControllerCreate', 'createMessageTemplateDto', createMessageTemplateDto)
            const localVarPath = `/message-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a message template
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerDelete: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('messageTemplatesControllerDelete', 'name', name)
            const localVarPath = `/message-templates/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all message templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerFindAllByAccountId: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/message-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a message template by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerFindOne: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('messageTemplatesControllerFindOne', 'name', name)
            const localVarPath = `/message-templates/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Render an email template with parameters
         * @param {string} name 
         * @param {MessageTemplatesControllerRenderTemplateTypeEnum} type Type of the template
         * @param {object} body AVJ Parameters for the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerRenderTemplate: async (name: string, type: MessageTemplatesControllerRenderTemplateTypeEnum, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('messageTemplatesControllerRenderTemplate', 'name', name)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('messageTemplatesControllerRenderTemplate', 'type', type)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('messageTemplatesControllerRenderTemplate', 'body', body)
            const localVarPath = `/message-templates/{name}/render/{type}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a message template
         * @param {string} name 
         * @param {UpdateMessageTemplateDto} updateMessageTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerUpdate: async (name: string, updateMessageTemplateDto: UpdateMessageTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('messageTemplatesControllerUpdate', 'name', name)
            // verify required parameter 'updateMessageTemplateDto' is not null or undefined
            assertParamExists('messageTemplatesControllerUpdate', 'updateMessageTemplateDto', updateMessageTemplateDto)
            const localVarPath = `/message-templates/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMessageTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicMessageTemplatesApi - functional programming interface
 * @export
 */
export const PublicMessageTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicMessageTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new message template
         * @param {CreateMessageTemplateDto} createMessageTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageTemplatesControllerCreate(createMessageTemplateDto: CreateMessageTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMessageTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageTemplatesControllerCreate(createMessageTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicMessageTemplatesApi.messageTemplatesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a message template
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageTemplatesControllerDelete(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageTemplatesControllerDelete(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicMessageTemplatesApi.messageTemplatesControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all message templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageTemplatesControllerFindAllByAccountId(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageTemplateDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageTemplatesControllerFindAllByAccountId(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicMessageTemplatesApi.messageTemplatesControllerFindAllByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a message template by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageTemplatesControllerFindOne(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageTemplatesControllerFindOne(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicMessageTemplatesApi.messageTemplatesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Render an email template with parameters
         * @param {string} name 
         * @param {MessageTemplatesControllerRenderTemplateTypeEnum} type Type of the template
         * @param {object} body AVJ Parameters for the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageTemplatesControllerRenderTemplate(name: string, type: MessageTemplatesControllerRenderTemplateTypeEnum, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageTemplatesControllerRenderTemplate(name, type, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicMessageTemplatesApi.messageTemplatesControllerRenderTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a message template
         * @param {string} name 
         * @param {UpdateMessageTemplateDto} updateMessageTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageTemplatesControllerUpdate(name: string, updateMessageTemplateDto: UpdateMessageTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageTemplatesControllerUpdate(name, updateMessageTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicMessageTemplatesApi.messageTemplatesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicMessageTemplatesApi - factory interface
 * @export
 */
export const PublicMessageTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicMessageTemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new message template
         * @param {CreateMessageTemplateDto} createMessageTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerCreate(createMessageTemplateDto: CreateMessageTemplateDto, options?: any): AxiosPromise<CreateMessageTemplateDto> {
            return localVarFp.messageTemplatesControllerCreate(createMessageTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a message template
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerDelete(name: string, options?: any): AxiosPromise<MessageTemplateDto> {
            return localVarFp.messageTemplatesControllerDelete(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all message templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerFindAllByAccountId(options?: any): AxiosPromise<Array<MessageTemplateDto>> {
            return localVarFp.messageTemplatesControllerFindAllByAccountId(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a message template by name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerFindOne(name: string, options?: any): AxiosPromise<MessageTemplateDto> {
            return localVarFp.messageTemplatesControllerFindOne(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Render an email template with parameters
         * @param {string} name 
         * @param {MessageTemplatesControllerRenderTemplateTypeEnum} type Type of the template
         * @param {object} body AVJ Parameters for the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerRenderTemplate(name: string, type: MessageTemplatesControllerRenderTemplateTypeEnum, body: object, options?: any): AxiosPromise<void> {
            return localVarFp.messageTemplatesControllerRenderTemplate(name, type, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a message template
         * @param {string} name 
         * @param {UpdateMessageTemplateDto} updateMessageTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTemplatesControllerUpdate(name: string, updateMessageTemplateDto: UpdateMessageTemplateDto, options?: any): AxiosPromise<MessageTemplateDto> {
            return localVarFp.messageTemplatesControllerUpdate(name, updateMessageTemplateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicMessageTemplatesApi - object-oriented interface
 * @export
 * @class PublicMessageTemplatesApi
 * @extends {BaseAPI}
 */
export class PublicMessageTemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new message template
     * @param {CreateMessageTemplateDto} createMessageTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicMessageTemplatesApi
     */
    public messageTemplatesControllerCreate(createMessageTemplateDto: CreateMessageTemplateDto, options?: RawAxiosRequestConfig) {
        return PublicMessageTemplatesApiFp(this.configuration).messageTemplatesControllerCreate(createMessageTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a message template
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicMessageTemplatesApi
     */
    public messageTemplatesControllerDelete(name: string, options?: RawAxiosRequestConfig) {
        return PublicMessageTemplatesApiFp(this.configuration).messageTemplatesControllerDelete(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all message templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicMessageTemplatesApi
     */
    public messageTemplatesControllerFindAllByAccountId(options?: RawAxiosRequestConfig) {
        return PublicMessageTemplatesApiFp(this.configuration).messageTemplatesControllerFindAllByAccountId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a message template by name
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicMessageTemplatesApi
     */
    public messageTemplatesControllerFindOne(name: string, options?: RawAxiosRequestConfig) {
        return PublicMessageTemplatesApiFp(this.configuration).messageTemplatesControllerFindOne(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Render an email template with parameters
     * @param {string} name 
     * @param {MessageTemplatesControllerRenderTemplateTypeEnum} type Type of the template
     * @param {object} body AVJ Parameters for the template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicMessageTemplatesApi
     */
    public messageTemplatesControllerRenderTemplate(name: string, type: MessageTemplatesControllerRenderTemplateTypeEnum, body: object, options?: RawAxiosRequestConfig) {
        return PublicMessageTemplatesApiFp(this.configuration).messageTemplatesControllerRenderTemplate(name, type, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a message template
     * @param {string} name 
     * @param {UpdateMessageTemplateDto} updateMessageTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicMessageTemplatesApi
     */
    public messageTemplatesControllerUpdate(name: string, updateMessageTemplateDto: UpdateMessageTemplateDto, options?: RawAxiosRequestConfig) {
        return PublicMessageTemplatesApiFp(this.configuration).messageTemplatesControllerUpdate(name, updateMessageTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MessageTemplatesControllerRenderTemplateTypeEnum = {
    Text: 'text',
    Html: 'html'
} as const;
export type MessageTemplatesControllerRenderTemplateTypeEnum = typeof MessageTemplatesControllerRenderTemplateTypeEnum[keyof typeof MessageTemplatesControllerRenderTemplateTypeEnum];


/**
 * PublicMessagesApi - axios parameter creator
 * @export
 */
export const PublicMessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The actorId is the ID of the actor that is posting the message. The message will be sent using the actor definition and using the actor channel defined in the actor definition.
         * @summary Post a message in a thread
         * @param {string} topicID The ID of the parent topic
         * @param {string} threadId The ID of the thread
         * @param {CreateMessageDTO} createMessageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerReplyInThread: async (topicID: string, threadId: string, createMessageDTO: CreateMessageDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicID' is not null or undefined
            assertParamExists('messagesControllerReplyInThread', 'topicID', topicID)
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('messagesControllerReplyInThread', 'threadId', threadId)
            // verify required parameter 'createMessageDTO' is not null or undefined
            assertParamExists('messagesControllerReplyInThread', 'createMessageDTO', createMessageDTO)
            const localVarPath = `/coms/topics/{topicID}/threads/{threadId}/messages`
                .replace(`{${"topicID"}}`, encodeURIComponent(String(topicID)))
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicMessagesApi - functional programming interface
 * @export
 */
export const PublicMessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicMessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * The actorId is the ID of the actor that is posting the message. The message will be sent using the actor definition and using the actor channel defined in the actor definition.
         * @summary Post a message in a thread
         * @param {string} topicID The ID of the parent topic
         * @param {string} threadId The ID of the thread
         * @param {CreateMessageDTO} createMessageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesControllerReplyInThread(topicID: string, threadId: string, createMessageDTO: CreateMessageDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesControllerReplyInThread(topicID, threadId, createMessageDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicMessagesApi.messagesControllerReplyInThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicMessagesApi - factory interface
 * @export
 */
export const PublicMessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicMessagesApiFp(configuration)
    return {
        /**
         * The actorId is the ID of the actor that is posting the message. The message will be sent using the actor definition and using the actor channel defined in the actor definition.
         * @summary Post a message in a thread
         * @param {string} topicID The ID of the parent topic
         * @param {string} threadId The ID of the thread
         * @param {CreateMessageDTO} createMessageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerReplyInThread(topicID: string, threadId: string, createMessageDTO: CreateMessageDTO, options?: any): AxiosPromise<Array<MessageDTO>> {
            return localVarFp.messagesControllerReplyInThread(topicID, threadId, createMessageDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicMessagesApi - object-oriented interface
 * @export
 * @class PublicMessagesApi
 * @extends {BaseAPI}
 */
export class PublicMessagesApi extends BaseAPI {
    /**
     * The actorId is the ID of the actor that is posting the message. The message will be sent using the actor definition and using the actor channel defined in the actor definition.
     * @summary Post a message in a thread
     * @param {string} topicID The ID of the parent topic
     * @param {string} threadId The ID of the thread
     * @param {CreateMessageDTO} createMessageDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicMessagesApi
     */
    public messagesControllerReplyInThread(topicID: string, threadId: string, createMessageDTO: CreateMessageDTO, options?: RawAxiosRequestConfig) {
        return PublicMessagesApiFp(this.configuration).messagesControllerReplyInThread(topicID, threadId, createMessageDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicQueueApi - axios parameter creator
 * @export
 */
export const PublicQueueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all messages in the queue
         * @summary Get all messages in the queue
         * @param {any} id The ID of the message
         * @param {QueueControllerFindAllStatusEnum} [status] The status of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueControllerFindAll: async (id: any, status?: QueueControllerFindAllStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('queueControllerFindAll', 'id', id)
            const localVarPath = `/coms/queue`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of a message in the queue
         * @summary Update the status of a message in the queue
         * @param {string} id The ID of the message
         * @param {QueueControllerUpdateStatusStatusEnum} status The status of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueControllerUpdateStatus: async (id: string, status: QueueControllerUpdateStatusStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('queueControllerUpdateStatus', 'id', id)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('queueControllerUpdateStatus', 'status', status)
            const localVarPath = `/coms/queue/update-status/{id}/{status}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicQueueApi - functional programming interface
 * @export
 */
export const PublicQueueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicQueueApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all messages in the queue
         * @summary Get all messages in the queue
         * @param {any} id The ID of the message
         * @param {QueueControllerFindAllStatusEnum} [status] The status of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueControllerFindAll(id: any, status?: QueueControllerFindAllStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QueueDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueControllerFindAll(id, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicQueueApi.queueControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of a message in the queue
         * @summary Update the status of a message in the queue
         * @param {string} id The ID of the message
         * @param {QueueControllerUpdateStatusStatusEnum} status The status of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueControllerUpdateStatus(id: string, status: QueueControllerUpdateStatusStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueControllerUpdateStatus(id, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicQueueApi.queueControllerUpdateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicQueueApi - factory interface
 * @export
 */
export const PublicQueueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicQueueApiFp(configuration)
    return {
        /**
         * Get all messages in the queue
         * @summary Get all messages in the queue
         * @param {any} id The ID of the message
         * @param {QueueControllerFindAllStatusEnum} [status] The status of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueControllerFindAll(id: any, status?: QueueControllerFindAllStatusEnum, options?: any): AxiosPromise<Array<QueueDto>> {
            return localVarFp.queueControllerFindAll(id, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of a message in the queue
         * @summary Update the status of a message in the queue
         * @param {string} id The ID of the message
         * @param {QueueControllerUpdateStatusStatusEnum} status The status of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueControllerUpdateStatus(id: string, status: QueueControllerUpdateStatusStatusEnum, options?: any): AxiosPromise<QueueDto> {
            return localVarFp.queueControllerUpdateStatus(id, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicQueueApi - object-oriented interface
 * @export
 * @class PublicQueueApi
 * @extends {BaseAPI}
 */
export class PublicQueueApi extends BaseAPI {
    /**
     * Get all messages in the queue
     * @summary Get all messages in the queue
     * @param {any} id The ID of the message
     * @param {QueueControllerFindAllStatusEnum} [status] The status of the message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicQueueApi
     */
    public queueControllerFindAll(id: any, status?: QueueControllerFindAllStatusEnum, options?: RawAxiosRequestConfig) {
        return PublicQueueApiFp(this.configuration).queueControllerFindAll(id, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of a message in the queue
     * @summary Update the status of a message in the queue
     * @param {string} id The ID of the message
     * @param {QueueControllerUpdateStatusStatusEnum} status The status of the message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicQueueApi
     */
    public queueControllerUpdateStatus(id: string, status: QueueControllerUpdateStatusStatusEnum, options?: RawAxiosRequestConfig) {
        return PublicQueueApiFp(this.configuration).queueControllerUpdateStatus(id, status, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const QueueControllerFindAllStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed',
    Skipped: 'skipped',
    Ignored: 'ignored',
    Deleted: 'deleted',
    Archived: 'archived',
    Spam: 'spam',
    Ham: 'ham',
    Bounce: 'bounce',
    Complaint: 'complaint',
    Unsubscribed: 'unsubscribed',
    Other: 'other'
} as const;
export type QueueControllerFindAllStatusEnum = typeof QueueControllerFindAllStatusEnum[keyof typeof QueueControllerFindAllStatusEnum];
/**
 * @export
 */
export const QueueControllerUpdateStatusStatusEnum = {
    Pending: 'pending',
    Ignored: 'ignored'
} as const;
export type QueueControllerUpdateStatusStatusEnum = typeof QueueControllerUpdateStatusStatusEnum[keyof typeof QueueControllerUpdateStatusStatusEnum];


/**
 * PublicThreadsApi - axios parameter creator
 * @export
 */
export const PublicThreadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new thread
         * @param {string} topicID The ID of the parent topic
         * @param {CreateThreadDTO} createThreadDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsControllerCreate: async (topicID: string, createThreadDTO: CreateThreadDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicID' is not null or undefined
            assertParamExists('threadsControllerCreate', 'topicID', topicID)
            // verify required parameter 'createThreadDTO' is not null or undefined
            assertParamExists('threadsControllerCreate', 'createThreadDTO', createThreadDTO)
            const localVarPath = `/coms/topics/{topicID}/threads`
                .replace(`{${"topicID"}}`, encodeURIComponent(String(topicID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createThreadDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all threads
         * @param {string} topicID The ID of the parent topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsControllerFindAll: async (topicID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicID' is not null or undefined
            assertParamExists('threadsControllerFindAll', 'topicID', topicID)
            const localVarPath = `/coms/topics/{topicID}/threads`
                .replace(`{${"topicID"}}`, encodeURIComponent(String(topicID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a thread by ID
         * @param {string} threadId The ID of the thread
         * @param {string} topicID The ID of the parent topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsControllerFindById: async (threadId: string, topicID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('threadsControllerFindById', 'threadId', threadId)
            // verify required parameter 'topicID' is not null or undefined
            assertParamExists('threadsControllerFindById', 'topicID', topicID)
            const localVarPath = `/coms/topics/{topicID}/threads/{threadId}`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"topicID"}}`, encodeURIComponent(String(topicID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all messages in a thread
         * @param {string} threadId The ID of the thread
         * @param {string} topicID The ID of the parent topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsControllerGetTopicMessages: async (threadId: string, topicID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('threadsControllerGetTopicMessages', 'threadId', threadId)
            // verify required parameter 'topicID' is not null or undefined
            assertParamExists('threadsControllerGetTopicMessages', 'topicID', topicID)
            const localVarPath = `/coms/topics/{topicID}/threads/{threadId}/messages`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"topicID"}}`, encodeURIComponent(String(topicID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicThreadsApi - functional programming interface
 * @export
 */
export const PublicThreadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicThreadsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new thread
         * @param {string} topicID The ID of the parent topic
         * @param {CreateThreadDTO} createThreadDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsControllerCreate(topicID: string, createThreadDTO: CreateThreadDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.threadsControllerCreate(topicID, createThreadDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicThreadsApi.threadsControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all threads
         * @param {string} topicID The ID of the parent topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsControllerFindAll(topicID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThreadDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.threadsControllerFindAll(topicID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicThreadsApi.threadsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a thread by ID
         * @param {string} threadId The ID of the thread
         * @param {string} topicID The ID of the parent topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsControllerFindById(threadId: string, topicID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.threadsControllerFindById(threadId, topicID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicThreadsApi.threadsControllerFindById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all messages in a thread
         * @param {string} threadId The ID of the thread
         * @param {string} topicID The ID of the parent topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsControllerGetTopicMessages(threadId: string, topicID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.threadsControllerGetTopicMessages(threadId, topicID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicThreadsApi.threadsControllerGetTopicMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicThreadsApi - factory interface
 * @export
 */
export const PublicThreadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicThreadsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new thread
         * @param {string} topicID The ID of the parent topic
         * @param {CreateThreadDTO} createThreadDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsControllerCreate(topicID: string, createThreadDTO: CreateThreadDTO, options?: any): AxiosPromise<ThreadDTO> {
            return localVarFp.threadsControllerCreate(topicID, createThreadDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all threads
         * @param {string} topicID The ID of the parent topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsControllerFindAll(topicID: string, options?: any): AxiosPromise<Array<ThreadDTO>> {
            return localVarFp.threadsControllerFindAll(topicID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a thread by ID
         * @param {string} threadId The ID of the thread
         * @param {string} topicID The ID of the parent topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsControllerFindById(threadId: string, topicID: string, options?: any): AxiosPromise<ThreadDTO> {
            return localVarFp.threadsControllerFindById(threadId, topicID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all messages in a thread
         * @param {string} threadId The ID of the thread
         * @param {string} topicID The ID of the parent topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsControllerGetTopicMessages(threadId: string, topicID: string, options?: any): AxiosPromise<Array<MessageDTO>> {
            return localVarFp.threadsControllerGetTopicMessages(threadId, topicID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicThreadsApi - object-oriented interface
 * @export
 * @class PublicThreadsApi
 * @extends {BaseAPI}
 */
export class PublicThreadsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new thread
     * @param {string} topicID The ID of the parent topic
     * @param {CreateThreadDTO} createThreadDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicThreadsApi
     */
    public threadsControllerCreate(topicID: string, createThreadDTO: CreateThreadDTO, options?: RawAxiosRequestConfig) {
        return PublicThreadsApiFp(this.configuration).threadsControllerCreate(topicID, createThreadDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all threads
     * @param {string} topicID The ID of the parent topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicThreadsApi
     */
    public threadsControllerFindAll(topicID: string, options?: RawAxiosRequestConfig) {
        return PublicThreadsApiFp(this.configuration).threadsControllerFindAll(topicID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a thread by ID
     * @param {string} threadId The ID of the thread
     * @param {string} topicID The ID of the parent topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicThreadsApi
     */
    public threadsControllerFindById(threadId: string, topicID: string, options?: RawAxiosRequestConfig) {
        return PublicThreadsApiFp(this.configuration).threadsControllerFindById(threadId, topicID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all messages in a thread
     * @param {string} threadId The ID of the thread
     * @param {string} topicID The ID of the parent topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicThreadsApi
     */
    public threadsControllerGetTopicMessages(threadId: string, topicID: string, options?: RawAxiosRequestConfig) {
        return PublicThreadsApiFp(this.configuration).threadsControllerGetTopicMessages(threadId, topicID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicTopicsApi - axios parameter creator
 * @export
 */
export const PublicTopicsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new topic
         * @param {CreateTopicDTO} createTopicDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicsControllerCreate: async (createTopicDTO: CreateTopicDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTopicDTO' is not null or undefined
            assertParamExists('topicsControllerCreate', 'createTopicDTO', createTopicDTO)
            const localVarPath = `/coms/topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTopicDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all topics
         * @param {object} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicsControllerFindAll: async (filter?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coms/topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a topic by ID
         * @param {string} id The ID of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicsControllerFindById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('topicsControllerFindById', 'id', id)
            const localVarPath = `/coms/topics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-auth-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicTopicsApi - functional programming interface
 * @export
 */
export const PublicTopicsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicTopicsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new topic
         * @param {CreateTopicDTO} createTopicDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicsControllerCreate(createTopicDTO: CreateTopicDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topicsControllerCreate(createTopicDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicTopicsApi.topicsControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all topics
         * @param {object} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicsControllerFindAll(filter?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopicDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topicsControllerFindAll(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicTopicsApi.topicsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a topic by ID
         * @param {string} id The ID of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicsControllerFindById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topicsControllerFindById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicTopicsApi.topicsControllerFindById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicTopicsApi - factory interface
 * @export
 */
export const PublicTopicsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicTopicsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new topic
         * @param {CreateTopicDTO} createTopicDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicsControllerCreate(createTopicDTO: CreateTopicDTO, options?: any): AxiosPromise<TopicDTO> {
            return localVarFp.topicsControllerCreate(createTopicDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all topics
         * @param {object} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicsControllerFindAll(filter?: object, options?: any): AxiosPromise<Array<TopicDTO>> {
            return localVarFp.topicsControllerFindAll(filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a topic by ID
         * @param {string} id The ID of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicsControllerFindById(id: string, options?: any): AxiosPromise<TopicDTO> {
            return localVarFp.topicsControllerFindById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicTopicsApi - object-oriented interface
 * @export
 * @class PublicTopicsApi
 * @extends {BaseAPI}
 */
export class PublicTopicsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new topic
     * @param {CreateTopicDTO} createTopicDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTopicsApi
     */
    public topicsControllerCreate(createTopicDTO: CreateTopicDTO, options?: RawAxiosRequestConfig) {
        return PublicTopicsApiFp(this.configuration).topicsControllerCreate(createTopicDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all topics
     * @param {object} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTopicsApi
     */
    public topicsControllerFindAll(filter?: object, options?: RawAxiosRequestConfig) {
        return PublicTopicsApiFp(this.configuration).topicsControllerFindAll(filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a topic by ID
     * @param {string} id The ID of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicTopicsApi
     */
    public topicsControllerFindById(id: string, options?: RawAxiosRequestConfig) {
        return PublicTopicsApiFp(this.configuration).topicsControllerFindById(id, options).then((request) => request(this.axios, this.basePath));
    }
}



